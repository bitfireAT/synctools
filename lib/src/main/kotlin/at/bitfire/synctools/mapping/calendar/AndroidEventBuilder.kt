/*
 * This file is part of bitfireAT/synctools which is released under GPLv3.
 * Copyright © All Contributors. See the LICENSE and AUTHOR files in the root directory for details.
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package at.bitfire.synctools.mapping.calendar

import android.content.ContentValues
import android.content.Entity
import at.bitfire.ical4android.Event
import at.bitfire.synctools.icalendar.AssociatedEvents
import at.bitfire.synctools.icalendar.isRecurring
import at.bitfire.synctools.mapping.calendar.builder.AndroidEventFieldBuilder
import at.bitfire.synctools.storage.calendar.AndroidCalendar
import at.bitfire.synctools.storage.calendar.EventAndExceptions
import net.fortuna.ical4j.model.component.VEvent

/**
 * Maps
 *
 * - an iCalendar object that contains VEVENTs and exceptions ([AssociatedEvents]) to
 * - Android event data rows (including exceptions → [EventAndExceptions]).
 *
 * The built fields must contain `null` values for empty fields so that they can be used for updates.
 *
 * _Migration note:_ Until a fields are built by [AndroidEventFieldBuilder]s, the rest is still
 * generated by [LegacyAndroidEventBuilder2].
 */
class AndroidEventBuilder(
    // AndroidEvent-level fields
    private val syncId: String,
    private val eTag: String?,
    private val scheduleTag: String?,
    private val flags: Int,

    // for new builders
    private val associatedEvents: AssociatedEvents,

    // only for legacy builder
    private val androidCalendar: AndroidCalendar,
    private val event: Event,
    private val id: Long?
) {

    fun build(): EventAndExceptions? {
        // start with legacy EventAndExceptions
        val eventAndExceptions = LegacyAndroidEventBuilder2(
            androidCalendar, event, id, syncId, eTag, scheduleTag, flags
        ).build()

        // merge with values from new builders
        val newEventAndExceptions = buildNew()
        if (newEventAndExceptions != null) {
            // merge main values
            eventAndExceptions.main.entityValues.putAll(newEventAndExceptions.main.entityValues)

            // merge sub-values
            // implement as soon as first sub-values are done by new builders

        } else {
            // Implement as soon as we have builders that return false to indicate that the Entity must be discarded
            // (for instance when there is no DTSTART).
        }

        return eventAndExceptions
    }

    private fun buildNew(): EventAndExceptions? {
        val mainEvent = associatedEvents.main ?: fakeMainEvent(associatedEvents.exceptions)
        val mayHaveExceptions = mainEvent.isRecurring()

        return EventAndExceptions(
            main = buildEvent(from = mainEvent, main = mainEvent) ?: return null,
            exceptions =
                if (mayHaveExceptions)
                    associatedEvents.exceptions.mapNotNull { exception ->
                        buildEvent(from = exception, main = mainEvent)
                    }
                else
                    emptyList()
        )
    }

    private fun buildEvent(from: VEvent, main: VEvent): Entity? {
        val result = Entity(ContentValues())
        for (builder in getBuilders())
            if (!builder.build(from = from, main = main, to = result)) {
                // discard entity when builder returns null
                return null
            }
        return result
    }

    fun getBuilders(): List<AndroidEventFieldBuilder> = listOf(
        TitleBuilder()
    )

    private fun fakeMainEvent(forExceptions: List<VEvent>): VEvent = TODO()

}