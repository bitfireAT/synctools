/*
 * This file is part of bitfireAT/synctools which is released under GPLv3.
 * Copyright © All Contributors. See the LICENSE and AUTHOR files in the root directory for details.
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package at.bitfire.synctools.mapping.calendar

import android.content.ContentValues
import android.content.Entity
import androidx.annotation.VisibleForTesting
import at.bitfire.ical4android.Event
import at.bitfire.synctools.icalendar.AssociatedEvents
import at.bitfire.synctools.icalendar.isRecurring
import at.bitfire.synctools.mapping.calendar.builder.AndroidEventFieldBuilder
import at.bitfire.synctools.mapping.calendar.builder.OriginalInstanceTimeBuilder
import at.bitfire.synctools.mapping.calendar.builder.TitleBuilder
import at.bitfire.synctools.storage.calendar.AndroidCalendar
import at.bitfire.synctools.storage.calendar.EventAndExceptions
import net.fortuna.ical4j.model.component.VEvent

/**
 * Maps
 *
 * - an iCalendar object that contains VEVENTs and exceptions ([AssociatedEvents]) to
 * - Android event data rows (including exceptions → [EventAndExceptions]).
 *
 * The built fields must contain `null` values for empty fields so that they can be used for updates.
 *
 * _Migration note:_ Until a fields are built by [AndroidEventFieldBuilder]s, the rest is still
 * generated by [LegacyAndroidEventBuilder2].
 */
class AndroidEventBuilder(
    // AndroidEvent-level fields
    private val syncId: String,
    private val eTag: String?,
    private val scheduleTag: String?,
    private val flags: Int,

    // for new builders
    private val associatedEvents: AssociatedEvents,

    // only for legacy builder
    private val androidCalendar: AndroidCalendar,
    private val event: Event,
    private val id: Long?
) {

    fun build(): EventAndExceptions? {
        // start with values from new builders
        val eventAndExceptions = buildNew()
        if (eventAndExceptions == null) {
            // builder has returned null to indicate that the main Entity must be discarded.
            // Without a main Entity, EventAndExceptions can't be generated, so return null here.
            return null
        }

        // merge with legacy EventAndExceptions
        val legacyEventAndExceptions = LegacyAndroidEventBuilder2(
            androidCalendar, event, id, syncId, eTag, scheduleTag, flags
        ).build()

        // ORIGINAL_INSTANCE_TIME must be set and the same for exceptions to be merged!
        // So ORIGINAL_INSTANCE_TIME must always be provided by both the old and the new builder.
        eventAndExceptions.mergeFrom(legacyEventAndExceptions)

        return eventAndExceptions
    }

    private fun buildNew(): EventAndExceptions? {
        val mainEvent = associatedEvents.main ?: fakeMainEvent(associatedEvents.exceptions)
        val mayHaveExceptions = mainEvent.isRecurring()

        return EventAndExceptions(
            main = buildEvent(from = mainEvent, main = mainEvent) ?: return null,
            exceptions =
                if (mayHaveExceptions)
                    associatedEvents.exceptions.mapNotNull { exception ->
                        buildEvent(from = exception, main = mainEvent)
                    }
                else
                    emptyList()
        )
    }

    @VisibleForTesting
    internal fun buildEvent(from: VEvent, main: VEvent): Entity? {
        val result = Entity(ContentValues())
        for (builder in getBuilders())
            if (!builder.build(from = from, main = main, to = result)) {
                // discard entity when builder returns null
                return null
            }
        return result
    }

    fun getBuilders(): List<AndroidEventFieldBuilder> = listOf(
        OriginalInstanceTimeBuilder(),
        TitleBuilder()
    )

    private fun fakeMainEvent(forExceptions: List<VEvent>): VEvent = TODO()

}