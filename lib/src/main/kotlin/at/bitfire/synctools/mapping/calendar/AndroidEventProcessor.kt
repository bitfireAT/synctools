/*
 * This file is part of bitfireAT/synctools which is released under GPLv3.
 * Copyright Â© All Contributors. See the LICENSE and AUTHOR files in the root directory for details.
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package at.bitfire.synctools.mapping.calendar

import android.content.Entity
import android.provider.CalendarContract
import android.provider.CalendarContract.Events
import android.provider.CalendarContract.ExtendedProperties
import androidx.annotation.VisibleForTesting
import at.bitfire.synctools.icalendar.AssociatedEvents
import at.bitfire.synctools.mapping.calendar.processor.AccessLevelProcessor
import at.bitfire.synctools.mapping.calendar.processor.AndroidEventFieldProcessor
import at.bitfire.synctools.mapping.calendar.processor.AttendeesProcessor
import at.bitfire.synctools.mapping.calendar.processor.AvailabilityProcessor
import at.bitfire.synctools.mapping.calendar.processor.CategoriesProcessor
import at.bitfire.synctools.mapping.calendar.processor.ColorProcessor
import at.bitfire.synctools.mapping.calendar.processor.DescriptionProcessor
import at.bitfire.synctools.mapping.calendar.processor.DurationProcessor
import at.bitfire.synctools.mapping.calendar.processor.EndTimeProcessor
import at.bitfire.synctools.mapping.calendar.processor.LocationProcessor
import at.bitfire.synctools.mapping.calendar.processor.OrganizerProcessor
import at.bitfire.synctools.mapping.calendar.processor.OriginalInstanceTimeProcessor
import at.bitfire.synctools.mapping.calendar.processor.RecurrenceFieldsProcessor
import at.bitfire.synctools.mapping.calendar.processor.RemindersProcessor
import at.bitfire.synctools.mapping.calendar.processor.SequenceProcessor
import at.bitfire.synctools.mapping.calendar.processor.StartTimeProcessor
import at.bitfire.synctools.mapping.calendar.processor.StatusProcessor
import at.bitfire.synctools.mapping.calendar.processor.TitleProcessor
import at.bitfire.synctools.mapping.calendar.processor.UidProcessor
import at.bitfire.synctools.mapping.calendar.processor.UnknownPropertiesProcessor
import at.bitfire.synctools.mapping.calendar.processor.UrlProcessor
import at.bitfire.synctools.storage.calendar.EventAndExceptions
import at.bitfire.synctools.storage.calendar.EventsContract
import net.fortuna.ical4j.model.DateList
import net.fortuna.ical4j.model.Property
import net.fortuna.ical4j.model.TimeZoneRegistryFactory
import net.fortuna.ical4j.model.component.VEvent
import net.fortuna.ical4j.model.parameter.Value
import net.fortuna.ical4j.model.property.ExDate
import net.fortuna.ical4j.model.property.RDate
import net.fortuna.ical4j.model.property.RRule
import net.fortuna.ical4j.model.property.RecurrenceId
import java.util.LinkedList
import java.util.UUID

/**
 * Mapper from Android event main + data rows to [VEvent].
 *
 * @param accountName       account name (used to generate self-attendee)
 * @param prodIdGenerator   generates the `PRODID` to use
 */
class AndroidEventProcessor(
    accountName: String,
    private val prodIdGenerator: ProdIdGenerator
) {

    private val tzRegistry = TimeZoneRegistryFactory.getInstance().createRegistry()

    private val fieldProcessors: Array<AndroidEventFieldProcessor> = arrayOf(
        // event row fields
        UidProcessor(),
        OriginalInstanceTimeProcessor(tzRegistry),
        TitleProcessor(),
        LocationProcessor(),
        StartTimeProcessor(tzRegistry),
        EndTimeProcessor(tzRegistry),
        DurationProcessor(tzRegistry),
        RecurrenceFieldsProcessor(tzRegistry),
        DescriptionProcessor(),
        ColorProcessor(),
        AccessLevelProcessor(),
        AvailabilityProcessor(),
        StatusProcessor(),
        // scheduling
        SequenceProcessor(),
        OrganizerProcessor(),
        AttendeesProcessor(),
        // extended properties
        CategoriesProcessor(),
        UnknownPropertiesProcessor(),
        UrlProcessor(),
        // sub-components
        RemindersProcessor(accountName)
    )


    /**
     * Result of the [mapToVEvents] operation.
     *
     * @param associatedEvents  mapped events
     * @param uid               UID of the mapped events
     * @param generatedUid      whether [uid] was generated by [mapToVEvents] (*false*: `UID` was already present before mapping)
     * @param updatedSequence   the new increased `SEQUENCE` of the main event (*null* if sequence was not increased by [mapToVEvents])
     */
    class MappingResult(
        val associatedEvents: AssociatedEvents,
        val uid: String,
        val generatedUid: Boolean,
        val updatedSequence: Int?
    )

    /**
     * Maps an Android event with its exceptions to VEVENTs.
     *
     * VEVENTs must have a valid `UID`, so this method (or better so say, the [UidProcessor] that it calls)
     * generates an UID, if necessary. If an `UID` was generated, it is noted in the result.
     *
     * This method also increases the `SEQUENCE`, if necessary, so that the mapped `SEQUENCE`
     * can be different than the original `SEQUENCE` in [eventAndExceptions]. If the `SEQUENCE` was
     * increased, it is noted in the result.
     */
    fun mapToVEvents(eventAndExceptions: EventAndExceptions): MappingResult {
        // make sure that main event has a UID
        var generatedUid = false
        val uid = provideUid(eventAndExceptions.main) {
            generatedUid = true
            UUID.randomUUID().toString()
        }

        val updatedSequence = increaseSequence(eventAndExceptions.main)

        // map main event
        val main = populateEvent(
            entity = eventAndExceptions.main,
            main = eventAndExceptions.main
        )

        // add exceptions of recurring main event
        val rRules = main.getProperties<RRule>(Property.RRULE)
        val rDates = main.getProperties<RDate>(Property.RDATE)
        val exceptions = LinkedList<VEvent>()
        if (rRules.isNotEmpty() || rDates.isNotEmpty()) {
            for (exception in eventAndExceptions.exceptions) {
                // convert exception to Event
                val exceptionEvent = populateEvent(
                    entity = exception,
                    main = eventAndExceptions.main
                )

                // make sure that exception has a RECURRENCE-ID
                val recurrenceId = exceptionEvent.recurrenceId ?: continue

                // generate EXDATE instead of VEVENT with RECURRENCE-ID for cancelled instances
                if (exception.entityValues.getAsInteger(Events.STATUS) == Events.STATUS_CANCELED)
                    main.properties += asExDate(exception, recurrenceId)
                else
                    exceptions += exceptionEvent
            }
        }

        val mappedEvents = AssociatedEvents(
            main = main,
            exceptions = exceptions,
            prodId = generateProdId(eventAndExceptions.main)
        )
        return MappingResult(
            associatedEvents = mappedEvents,
            uid = uid,
            generatedUid = generatedUid,
            updatedSequence = updatedSequence
        )
    }

    private fun asExDate(entity: Entity, recurrenceId: RecurrenceId): ExDate {
        val originalAllDay = (entity.entityValues.getAsInteger(Events.ORIGINAL_ALL_DAY) ?: 0) != 0
        val list = DateList(
            if (originalAllDay) Value.DATE else Value.DATE_TIME,
            recurrenceId.timeZone
        )
        list.add(recurrenceId.date)
        return ExDate(list).apply {
            // also set TZ properties of ExDate (not only the list)
            if (!originalAllDay) {
                if (recurrenceId.isUtc)
                    setUtc(true)
                else
                    timeZone = recurrenceId.timeZone
            }
        }
    }

    private fun generateProdId(main: Entity): String {
        val mutators: String? = main.entityValues.getAsString(Events.MUTATORS)
        val packages: List<String> = mutators?.split(MUTATORS_SEPARATOR)?.toList() ?: emptyList()
        return prodIdGenerator.generateProdId(packages)
    }

    /**
     * Increases the event's SEQUENCE, if necessary.
     *
     * @param main  event to be checked (**will be modified** when SEQUENCE needs to be increased)
     *
     * @return updated sequence (or *null* if sequence was not increased/modified)
     */
    @VisibleForTesting
    internal fun increaseSequence(main: Entity): Int? {
        val mainValues = main.entityValues
        val currentSeq = mainValues.getAsInteger(EventsContract.COLUMN_SEQUENCE)

        if (currentSeq == null) {
            /* First upload, request to set to 0 in calendar provider after upload.
            We can let it empty in the Entity because then no SEQUENCE property will be generated,
            which is equal to SEQUENCE:0. */
            return 0
        }

        val groupScheduled = main.subValues.any { it.uri == CalendarContract.Attendees.CONTENT_URI }
        if (groupScheduled) {
            val weAreOrganizer = mainValues.getAsInteger(Events.IS_ORGANIZER) == 1

            return if (weAreOrganizer) {
                /* Upload of a group-scheduled event and we are the organizer, so we increase the SEQUENCE.
                We also have to store it into the Entity so that it the new value will be mapped. */
                (currentSeq + 1).also { newSeq ->
                    mainValues.put(EventsContract.COLUMN_SEQUENCE, newSeq)
                }
            } else
                /* Upload of a group-scheduled event and we are not the organizer, so we don't increase the SEQUENCE. */
                null

        } else /* not group-scheduled */  {
            return if (currentSeq == 0) {
                /* The event was uploaded once and has SEQUENCE of 0 (which is mapped to an empty SEQUENCE property).
                We don't need to increase the SEQUENCE because the event is not group-scheduled. */
                null
            } else {
                /* Upload of a non-group-scheduled event where a SEQUENCE > 0 is present. Increase by one after upload.
                We also have to store it into the Entity so that it the new value will be mapped. */
                (currentSeq + 1).also { newSeq ->
                    mainValues.put(EventsContract.COLUMN_SEQUENCE, newSeq)
                }
            }
        }
    }

    /**
     * Reads data of an event from the calendar provider, i.e. converts the [entity] values into a [VEvent].
     *
     * @param entity            event row as returned by the calendar provider
     * @param main              main event row as returned by the calendar provider
     *
     * @return generated data object
     */
    private fun populateEvent(entity: Entity, main: Entity): VEvent {
        // initialization adds DTSTAMP
        val vEvent = VEvent(/* initialise = */ true)

        for (processor in fieldProcessors)
            processor.process(from = entity, main = main, to = vEvent)
        return vEvent
    }

    /**
     * Makes sure that the event has a UID ([Events.UID_2445] in the main event row).
     *
     * If the event doesn't have a UID, a new one is generated using [uidGenerator] and
     * put into [main].
     *
     * @param main  event to be checked (**will be modified** if it doesn't already have a UID)
     */
    private fun provideUid(
        main: Entity,
        generateUid: () -> String
    ): String {
        val mainValues = main.entityValues
        val existingUid = mainValues.getAsString(Events.UID_2445)
        if (existingUid != null) {
            // UID already present, nothing to do
            return existingUid
        }

        // have a look at extended properties (Google Calendar)
        val googleCalendarUid = main.subValues.firstOrNull {
            it.uri == ExtendedProperties.CONTENT_URI &&
            it.values.getAsString(ExtendedProperties.NAME) == EventsContract.EXTNAME_GOOGLE_CALENDAR_UID
        }?.values?.getAsString(ExtendedProperties.VALUE)
        if (googleCalendarUid != null) {
            // copy to UID_2445 so that it will be processed by UidProcessor and return
            mainValues.put(Events.UID_2445, googleCalendarUid)
            return googleCalendarUid
        }

        // still no UID, generate one
        val newUid = generateUid()
        mainValues.put(Events.UID_2445, newUid)
        return newUid
    }


    companion object {

        /**
         * The [Events.MUTATORS] field contains a list of unique package names that have modified the event,
         * separated by this separator.
         */
        const val MUTATORS_SEPARATOR = ','

    }
}